#ifndef PATH_H
#define PATH_H

#include <iostream>
#include <cstring>
#include <vector>

#include <ros/ros.h>
#include <tf/transform_datatypes.h>
#include <nav_msgs/Path.h>
#include <geometry_msgs/PoseStamped.h>
#include <geometry_msgs/PoseArray.h>
#include <visualization_msgs/MarkerArray.h>
#include <Eigen/Geometry>
#include <tf2_eigen/tf2_eigen.h>

#include "node3d.h"
#include "constants.h"
#include "helper.h"

#include <algorithm>
namespace HybridAStar {
/*!
   \brief A class for tracing and visualizing the path generated by the Planner
*/
class Path {
 public:
  /// The default constructor initializing the path object and setting publishers for the same.
  Path(bool smoothed = false) {
    std::string pathTopic = "/path";
    std::string pathNodesTopic = "/pathNodes";
    std::string pathVehicleTopic = "/pathVehicle";

    if (smoothed) {
      pathTopic = "/sPath";
      pathNodesTopic = "/sPathNodes";
      pathVehicleTopic = "/sPathVehicle";
      this->smoothed = smoothed;
    }

    // _________________
    // TOPICS TO PUBLISH
    pubPath = n.advertise<geometry_msgs::PoseArray>(pathTopic, 1);
    pubPathNodes = n.advertise<visualization_msgs::MarkerArray>(pathNodesTopic, 1);
    pubPathVehicles = n.advertise<visualization_msgs::MarkerArray>(pathVehicleTopic, 1);

    // CONFIGURE THE CONTAINER
    path.header.frame_id = "map";
  }

  //  // __________
  //  // TRACE PATH
  //  /*!
  //     \brief Given a node pointer the path to the root node will be traced recursively
  //     \param node a 3D node, usually the goal node
  //     \param i a parameter for counting the number of nodes
  //  */
  //  void tracePath(const Node3D* node, int i = 0);
  /*!
     \brief Given a node pointer the path to the root node will be traced recursively
     \param node a 3D node, usually the goal node
     \param i a parameter for counting the number of nodes
  */
  void updatePath(const std::vector<Node3D> &nodePath);
  /*!
     \brief Adds a segment to the path
     \param node a 3D node
  */
  void addSegment(const Node3D &node);
  /*!
     \brief Adds a node to the path
     \param node a 3D node
     \param i a parameter for counting the number of nodes
  */
  void addNode(const Node3D &node, int i);
  /*!
     \brief Adds a vehicle shape to the path
     \param node a 3D node
     \param i a parameter for counting the number of nodes
  */
  void addVehicle(const Node3D &node, int i);

  void setTransformMatrix(const geometry_msgs::TransformStamped &transform);

  // ______________
  // PUBLISH METHODS

  /// Clears the path
  void clear();
  /// Publishes the path
  void publishPath() {
    auto pose_to_matrix = [](const geometry_msgs::PoseStamped &pose) {
      Eigen::Matrix4d mat = Eigen::Matrix4d::Identity();
      const auto &pos = pose.pose.position;
      const auto &ori = pose.pose.orientation;
      Eigen::Quaterniond quat(ori.w, ori.x, ori.y, ori.z);
      mat.topLeftCorner<3, 3>() = quat.toRotationMatrix();
      mat.topRightCorner<3, 1>() = Eigen::Vector3d(pos.x, pos.y, pos.z);
      return mat;
    };

    auto transform_pose = [](const Eigen::Matrix4d &transformed_pose) {
      geometry_msgs::Pose pose_trans;
      Eigen::Quaterniond quat(transformed_pose.topLeftCorner<3, 3>());
      const Eigen::Vector3d &trans = transformed_pose.topRightCorner<3, 1>();
      pose_trans.position.x = trans.x();
      pose_trans.position.y = trans.y();
      pose_trans.position.z = trans.z();
      pose_trans.orientation.x = quat.x();
      pose_trans.orientation.y = quat.y();
      pose_trans.orientation.z = quat.z();
      pose_trans.orientation.w = quat.w();
      return pose_trans;
    };

    geometry_msgs::PoseArray poses;
    poses.header.frame_id = "base_link";
    poses.header.stamp = msg_stamp_;
    for (auto & pose : path.poses) {
      auto pose_matrix = pose_to_matrix(pose);
      auto transformed_pose_matrix = transform_matrix_hybrid_to_base_link.inverse() * pose_matrix;
      auto transformed_pose = transform_pose(transformed_pose_matrix);
      poses.poses.push_back(transformed_pose);
    }

    std::reverse(poses.poses.begin(),poses.poses.end());
    pubPath.publish(poses);
  }
  /// Publishes the nodes of the path
  void publishPathNodes() { pubPathNodes.publish(pathNodes); }
  /// Publishes the vehicle along the path
  void publishPathVehicles() { pubPathVehicles.publish(pathVehicles); }

 private:
  /// A handle to the ROS node
  ros::NodeHandle n;
  /// Publisher for the path as a spline
  ros::Publisher pubPath;
  /// Publisher for the nodes on the path
  ros::Publisher pubPathNodes;
  /// Publisher for the vehicle along the path
  ros::Publisher pubPathVehicles;
  /// Path data structure for visualization
  nav_msgs::Path path;
  /// Nodes data structure for visualization
  visualization_msgs::MarkerArray pathNodes;
  /// Vehicle data structure for visualization
  visualization_msgs::MarkerArray pathVehicles;
  /// Value that indicates that the path is smoothed/post processed
  bool smoothed = false;

  Eigen::Matrix4d transform_matrix_hybrid_to_base_link;
  ros::Time msg_stamp_;
};
}
#endif // PATH_H
